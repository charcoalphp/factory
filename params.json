{
  "name": "Charcoal-factory",
  "tagline": "Dynamic object creation (Factory/ AbstractFactory / Builder / Class Resolver)",
  "body": "Charcoal Factory\r\n================\r\n\r\nFactories create or build dynamic PHP objects.\r\n\r\n[![Build Status](https://travis-ci.org/locomotivemtl/charcoal-factory.svg?branch=master)](https://travis-ci.org/locomotivemtl/charcoal-factory)\r\n\r\n# Table of contents\r\n\r\n- How to install\r\n\t- Dependencies\r\n- Factories\r\n\t- About factories\r\n\t- Ensuring a type of object\r\n\t- Setting a default type of object\r\n\t- Constructor arguments\r\n\t- Executing an object callback\r\n\r\n# How to install\r\n\r\nThe preferred (and only supported) way of installing _charcoal-factory_ is with **composer**:\r\n\r\n```shell\r\n$ composer require locomotivemtl/charcoal-factory\r\n```\r\n\r\n## Dependencies\r\n\r\n- [`PHP 5.5+`](http://php.net)\r\n\t- Older versions of PHP are deprecated, therefore not supported for charcoal-factory.\r\n\r\n> ðŸ‘‰ Development dependencies, which are optional when using charcoal-factory, are described in the [Development](#development) section of this README file.\r\n\r\n\r\n# Factories\r\n\r\n## About factories\r\n\r\nFactories have only one purpose: to create / instanciate new PHP objects. There is 2 different methods of object creation:\r\n\r\n- Typically, the `create` method instantiates an object, from a class ident.\r\n- Additionnally, the `get` method can be called to retrieve the last created instance.\r\n\r\n```php\r\n$factory = new \\Charcoal\\Factory\\ResolverFactory();\r\n\r\n// Ensure the created object is a Charcoal Model\r\n$factory->setBaseClass('\\Charcoal\\Model\\ModelInterface');\r\n\r\n// Create a \"news\" object (from the `charcoal-cms` module)\r\n$factory->create('charcoal/cms/news');\r\n```\r\n\r\nThere are 3 default type of factory provided:\r\n\r\n### `GenericFactory`\r\n\r\nResolve the **class name** by using the requested **type** directly as the class name.\r\n\r\n### `MapFactory`\r\n\r\nResolve the **class name** from an associative array (_map_) with the requested **type** as key.\r\n\r\n### `ResolverFactory`\r\n\r\nResolves the **class name** from the `resolve()` method, which typically transform the requested **type** by:\r\n\r\n## Ensuring a type of object\r\n\r\nEnsuring a type of object can be done by setting the `baseClass`, either forced in a class:\r\n\r\n```php\r\nclass MyFactory extends AbstractFactory\r\n{\r\n\tpublic function baseClass()\r\n\t{\r\n\t\treturn '\\My\\Foo\\BaseClassInterface`;\r\n\t}\r\n}\r\n```\r\n\r\nOr, dynamically, with `setBaseClass()`:\r\n\r\n```php\r\n$factory = new ResolverFactory();\r\n$factory->setBaseClass('\\My\\Foo\\BaseClassInterface');\r\n```\r\n\r\n> ðŸ‘‰ Note that _Interfaces_ can also be used as a factory's base class.\r\n\r\n## Setting a default type of object\r\n\r\nIt is possible to set a default type of object (default class) by setting the `defaultClass`, either forced in a class:\r\n\r\n```php\r\nclass MyFactory extends AbstractFactory\r\n{\r\n\tpublic function defaultClass()\r\n\t{\r\n\t\treturn '\\My\\Foo\\DefaultClassInterface`;\r\n\t}\r\n}\r\n```\r\n\r\nOr, dynamically, with `setDefaultClass()`:\r\n\r\n```php\r\n$factory = new ResolverFactory();\r\n$factory->setDefaultClass('\\My\\Foo\\DefaultClassInterface');\r\n```\r\n\r\n> âš  Setting a default class name changes the standard Factory behavior. When an invalid class name is used, instead of throwing an `Exception`, an object of the default class type will **always** be returned.\r\n\r\n## Constructor arguments\r\n\r\nIt is possible to set \"automatic\" constructor arguments that will be passed to every created object.\r\n\r\nThe easiest way to achieve this is by passing the arguments as the 2nd parameter of a factory's `create()` method.\r\n\r\n```php\r\n$factory->create('foo/bar', [$args]);\r\n```\r\n\r\nAnother way of providing constructor arguments to a factory is with the `setArguments()` method. Assume that the `\\Foo\\Bar` object have the following constructor:\r\n\r\n```php\r\nnamespace \\Foo;\r\n\r\nclass Bar {\r\n\tpublic function __constructor($dependencies)\r\n\t{\r\n\t\t$this->setFooDependency($dependencies['foo']);\r\n\t\t$this->setBar($dependencies['bar']);\r\n\t}\r\n}\r\n```\r\n\r\nThen the following code will create an object with proper constructor arguments.\r\n\r\n```\r\n$factory = new \\Charcoal\\Factory\\MapFactory();\r\n$factory->setMap([\r\n\t'obj' => '\\Foo\\Bar'\r\n]);\r\n$factory->setArguments([\r\n\t'foo'=>new Dependency1(),\r\n\t'bar'=>new Dependency2()\r\n]);\r\n$obj = $factory->create('obj');\r\n```\r\n\r\n## Executing an object callback\r\n\r\nIt is possible to execute an object callback upon object instanciation by passing a `callable` object as the 3rd argument of the `create()` method. The callback should have the following signature:\r\n\r\n```php\r\n// $obj is the newly created object\r\nfunction callback($obj);\r\n```\r\n\r\nExample:\r\n\r\n```php\r\n$factory = new GenericFactory();\r\n$factory->setBaseClass('\\Foo\\BarInterface');\r\n$factory->setArguments([\r\n\t'logger'=>$container['logger']\r\n]);\r\n// Create a new object with a callback.\r\n$factory->create('\\Foo\\Bar', null, function(\\Foo\\Bar $obj) {\r\n  // Outputs the newly created `\\Foo\\Bar` object\r\n\tvar_dump($obj);\r\n});\r\n```\r\n\r\nAnother way of providing a callback is with the `setCallback()` method:\r\n\r\n```php\r\n$factory = new GenericFactory();\r\n$factory->setCallback(function(\\Foo\\Bar $obj) {\r\n\t// Outputs the newly created '\\Foo\\Bar' object\r\n\tvar_dump($obj);\r\n});\r\n```\r\n\r\n# The `AbstractFactory` API\r\n\r\n| Method                                 | Return value | Description |\r\n| -------------------------------------- | ------------ | ----------- |\r\n| `create(string $type [, array $args, callable $cb])` | _Object_     | Create a class from a \"type\" string. |\r\n| `get(string $type [, array $args])`    | _Object_     | Get returns the latest created class instance, or a new one if none exists. |\r\n| `setBase_class(string $classname)`    | _Chainable_  |             |\r\n| `baseClass()`                         | `string`     |             |\r\n| `setDefaultClass(string $classname)`  | _Chainable_  |             |\r\n| `defaultClass()`                      | `string`     |             |\r\n| `resolve(string $type)`               | `string`     | **abstract**, must be reimplemented in children classes. |\r\n| `isResolvable(string $type)`          | `boolean`    | **abstract**, must be reimplemented in children classes. |\r\n\r\n## The `MapFactory` additional API\r\n\r\n| Method                                       | Return value | Description |\r\n| -------------------------------------------- | ------------ | ----------- |\r\n| `addClass(string $type, string $class_name)` | _Chainable_  |             |\r\n| `setMap(array $map)`                         | _Chainable_  |             |\r\n| `map()`                                      | `array`      |             |\r\n\r\n## The `GenericFactory` additional API\r\n\r\nBecause the `ClassNameFactory` uses the parameter directly, there is no additional methods for this type of class.\r\n\r\nThe `resolve()` method simply returns its _type_ argument, and the `validate()` method simply ensures its _type_ argument is a valid (existing) class.\r\n\r\n## The `ResolverFactory` additional API\r\n\r\nThe `ResolverFactory` resolves the classname from the class resolver options:\r\n\r\n- `resolverPrefix` `string` that will be prepended to the resolved class name.\r\n- `resolverSuffix` `string` that will be appended to the resolved class name.\r\n- `resolverCapitals` `array` of characters that will cause the next character to be capitalized.\r\n- `resolverReplacements` `array`\r\n\r\n| Method                                           | Return value | Description |\r\n| -----------------------------------------------| ------------ | ----------- |\r\n| `setResolverPrefix(string $prefix)`            | _Chainable_  |             |\r\n| `resolverPrefix()`                             | `string`     |             |\r\n| `setResolverSuffix(string $suffix)`            | _Chainable_  |             |\r\n| `resolverSuffix()`                             | `string`     |             |\r\n| `setResolveCcapitals(array $capitals)`         | _Chainable_  |             |\r\n| `resolverCapitals()`                           | `array`      |             |\r\n| `setResolverReplacements(array $replacements)` | _Chainable_  |             |\r\n| `resolverReplacements()`                       | `array`      |             |\r\n\r\n# Development\r\n\r\nTo install the development environment:\r\n\r\n```shell\r\n$ npm install\r\n$ composer install\r\n```\r\n\r\n## Development dependencies\r\n\r\n- `npm`\r\n- `grunt` (install with `npm install grunt-cli`)\r\n- `composer`\r\n- `phpunit`\r\n\r\n## Coding Style\r\n\r\nAll Charcoal modules follow the same coding style and `charcoal-factory` is no exception. For PHP:\r\n\r\n- [_PSR-1_](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-1-basic-coding-standard.md)\r\n- [_PSR-2_](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-2-coding-style-guide.md)\r\n- [_PSR-4_](https://github.com/php-fig/fig-standards/blob/master/accepted/PSR-4-autoloader.md), autoloading is therefore provided by _Composer_\r\n- [_phpDocumentor_](http://phpdoc.org/)\r\n\t- Add DocBlocks for all classes, methods, and functions;\r\n- Naming conventions\r\n\t- Prefix abstract classes with `Abstract`;\r\n\t- Suffix interfaces with `Interface`, traits with `Trait`, exceptions with `Exception`;\r\n\t- For arrays, use short notation `[]` (instead of `array()`).\r\n\t- Read the [phpcs.xml](phpcs.xml) file for all the details.\r\n\r\nCoding styles are  enforced with `grunt phpcs` ([_PHP Code Sniffer_](https://github.com/squizlabs/PHP_CodeSniffer)). The actual ruleset can be found in `phpcs.xml`.\r\n\r\n> ðŸ‘‰ To fix minor coding style problems, run `grunt phpcbf` ([_PHP Code Beautifier and Fixer_](https://github.com/squizlabs/PHP_CodeSniffer)). This tool uses the same ruleset as *phpcs* to automatically correct coding standard violations.\r\n\r\n## Authors\r\n\r\n- Mathieu Ducharme <mat@locomotive.ca>\r\n\r\n## Changelog\r\n\r\n### 0.3\r\n\r\n- Add the `setArguments()` method to factories.\r\n- Add the `setCallback()` method to factories.\r\n- Execute the callback when using the default class too.\r\n\r\n\r\n### 0.2\r\n\r\n_Released 2016-01-26_\r\n\r\nMinor (but BC-breaking) changes to Charcoal-Factory\r\n\r\n- Full PSR1 compliancy (All methods are now camel-case).\r\n- Add a callback argument to the `create()` method.\r\n- `create()` and `get()` are now `final` in the base abstract factory class.\r\n- Internal code, docs and tool improvements.\r\n\r\n\r\n### 0.1\r\n\r\n_Released 2015-11-25_\r\n\r\n- Initial release\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}